# 設計模式原則

标签（空格分隔）： 設計模式

---

# 設計基礎


## 1.抽象

- 就是C＃將類給抽象化就是這只是類的模版，無法實例化

- 抽象與虛擬差異在於，抽象需要override 重寫，虛擬方法可以先寫好，要不要override 隨意

> 詳見 [(C#) 區分 abstract、virtual、override 和 new](http://jimmy0222.pixnet.net/blog/post/37271702)

>abstract => 抽象方法。
> virtual => 虛擬方法。
> override => 覆蓋基礎類別方法。
> new => 隱藏基礎類別方法。
> override 和 new 有時都叫覆寫基礎類別方法。

## 2.封裝

- 就是將數據封起來，避免被其他類引用，有以下這些方法，
  但實際上有其他方法，EX：用Void來取得數據

- 而且封裝在物件導向有時不是指數據封裝，是指類別封裝，將類別關起來

> public：所有對象都可以訪問；
> private：對象本身在對象內部可以訪問；
> protected：只有該類對象及其子類對象可以訪問
> internal：同一個程式集的對象可以訪問；
> protected internal：訪問限於當前程式集或派生自包含類的類型。

> get {return _firstName;}set {_firstName = value;} <=利用函式取得封裝數據



## 3.繼承
- 指的是子類繼承父類，而子類有父類所有非私有的數據，就是把父類的程式碼塞到子類裡
- C＃ 只能單一繼承

```csharp
public class A //父類
{
Protected int value = 10;
}

public class B : A//子類
{
public int GetValue(){return this.value;}
}

ClassB繼承後實際上程式碼變成這樣
public class B //子類
{
protected int value = 10;//這是父類的
public int GetValue(){return this.value;}//這是子類的
}
```

## 4.多態
- 就是一個類可以有很多種型態
EX:當子類繼承父類，宣告父類陣列時，子類也能放進去，因為子類有父類的型態
EX2:當類繼承介面Interface 宣告Interface 陣列時該類也能放進去，因為該類有Interface 型態

- 還有就是Void（函示）多態，只要後面接的變數不一樣，函示名字可以一樣
```
EX: 
Test()
Test(int a)
Test(int a,string b)
```


----------


# 設計模式7大原則

## 1.開閉原則

> 詳見 [程序员必备的七大面向对象设计原则（一）](https://blog.csdn.net/qiulongtianshi/article/details/7570021)

### **定義 : 對擴展開放，對修改關閉** 

#### 原則:
1. 開閉原則由Bertrand Meyer於1988年提出，它是面向對象設計中最重要的原則之一。
2. 在開閉原則的定義中，軟體實體可以指一個軟體模組、一個由多個類組成的局部結構或一個獨立的類。
3. 抽象化是開閉原則的關鍵。
4. 開閉原則還可以通過一個更加具體的“對可變性封裝原則”來描述，對可變性封裝原則(Principle of Encapsulation of Variation,EVP)要求找到系統的可變因素並將其封裝起來。


#### 案例:

![圖一](https://github.com/PeterLukGit/My_Unity_Exercise/blob/master/%E7%AD%86%E8%A8%98/%E7%AD%86%E8%A8%98%E5%9C%96%E7%89%87/%E9%96%8B%E9%96%89%E5%8E%9F%E5%89%87/00.PNG)

![圖二](https://github.com/PeterLukGit/My_Unity_Exercise/blob/master/%E7%AD%86%E8%A8%98/%E7%AD%86%E8%A8%98%E5%9C%96%E7%89%87/%E9%96%8B%E9%96%89%E5%8E%9F%E5%89%87/01.PNG)


##### 對比分析

- 圖（1）：客戶端的一個方法直接調用加法類，但是我想添加一個減法類，你就會發現添加減法類就得改變加法類中代碼（用switch語句實現），這就違背了“開閉原則”，於是我們就應該重新重構。

- 如圖（2）在這個圖中我們添加了一個運算類的父類，這樣我們再添加減法類的時候就不用修改客戶端類。

<!-- 
# **開閉原則總結：**
# **面對需求，對程式的改動是通過增加新代碼進行的，而不是改變原來的代碼。**
 -->

<b>
<font face="微软雅黑" color="red" size="10">
開閉原則總結：<br>
面對需求，對程式的改動是通過增加新代碼進行的，而不是改變原來的代碼
</font>
</b>

--------

## 2.依賴倒轉原則

> 參考附錄(一)高層模組和底層模組

1. 依賴倒轉原則定義
   - 高層模組不應該依賴低層模組，它們都應該依賴抽象。抽象不應該依賴於細節，細節應該依賴於抽象。
   - **要針對介面編程，不要針對實現編程。**

2. 依賴倒轉原則分析
a) 簡單來說，依賴倒轉原則就是指：代碼要依賴於抽象的類，而不要依賴於具體的類；要針對介面或抽象類編程，而不是針對具體類編程。
b) 實現開閉原則的關鍵是抽象化，並且從抽象化導出具體化實現，如果說開閉原則是面向對象設計的目標的話，那麼依賴倒轉原則就是面向對象設計的主要手段。
c) 依賴倒轉原則的常用實現方式之一是在代碼中使用抽象類，而將具體類放在配置檔中。
d) 類之間的耦合 1.零耦合關係 2.具體耦合關係  3.抽象耦合關係。依賴倒轉原則要求客戶端依賴於抽象耦合，以抽象方式耦合是依賴倒轉原則的關鍵。
e)  依賴注入:
構造注入：通過構造函數注入實例變數
設值注入：通過Setter方法注入實例變數
介面注入：通過介面方法注入實例變數


----------

# 附錄

## 附錄(一)高層模組和底層模組

### 依賴倒置原則裏面，什麼叫高層模組和底層模組？

>作者：蓋拉斯
>鏈接：https://www.zhihu.com/question/58471765/answer/311356521
>來源：知乎
>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請注明出處。

#### **可以簡單的理解：調用者為高層，被調用者為低層。**

關於這個模式，舉個現實生活中的例子：
某地市場上有很多肉店。你想在這裏開一家餃子館，由於當地法律規定餃子店不能自己剁肉，必須使用肉店提供的剁餡服務，所以你的採購員每天去肉店下單買肉，然後等現場剁成肉餡後再帶回店裏做成豬肉餃子。

餃子店生意還不錯，但是你是個有理想的店主，不甘心賣一輩子豬肉餃子，所以你決定……拓展一下店裏的餃子品種。經過一番調研，你發現有三家肉店的老闆剛好家裏種了白菜、芹菜和韭菜——所以這三家還分別供應白菜肉餡、芹菜肉餡和韭菜肉餡。於是你在菜單上就增加了這三種蔬菜肉餡的餃子。由於你的採購員一天最多只能跑兩個地兒，而現在每天要跑三家肉店，一個人忙不過來，於是你不得不新招了一位採購員。

過了一陣，某肉店老闆參加了一場設計模式，哦不，商業模式的培訓，回去後就推出了一項新的服務：可以允許你自己把任何蔬菜類的食材帶過去，然後幫你做對應的蔬菜肉餡。你作為一個奸商（誤）一聽到這消息高興壞了，現在採購員只需要跑一下菜市場，然後跑一下這家肉店，就能滿足店內的三種肉餡需要了。甚至以後想拓展更多種類的肉餡也沒有什麼額外負擔。所以新招的採購員分分鐘就被你辭退了。

這就是依賴倒置。你的餃子店是高層模組，肉店則是低層模組。
混合肉餡依賴一種蔬菜食材，但原先的店都是自己準備固定的某種蔬菜，所以每當你想多賣一種蔬菜肉餡餃子，都得先看看有沒有提供這種餃子餡的肉店。但後來的這家肉店，把做肉餡所依賴的蔬菜食材交給你來決定，所以你的採購方案和菜單制訂一下子就變得非常靈活，任何蔬菜肉餡，只要菜市場能買到對應的蔬菜，你就可以交給這家店幫你做好。通過這種模式，一家肉店就解決了你的需求。
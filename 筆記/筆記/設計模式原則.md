# 設計模式原則

标签（空格分隔）： 設計模式

---

# 設計基礎

## 1.抽象

- 就是C＃將類給抽象化就是這只是類的模版，無法實例化

- 抽象與虛擬差異在於，抽象需要override 重寫，虛擬方法可以先寫好，要不要override 隨意

> 詳見 [(C#) 區分 abstract、virtual、override 和 new](http://jimmy0222.pixnet.net/blog/post/37271702)

>abstract => 抽象方法。
> virtual => 虛擬方法。
> override => 覆蓋基礎類別方法。
> new => 隱藏基礎類別方法。
> override 和 new 有時都叫覆寫基礎類別方法。

## 2.封裝

- 就是將數據封起來，避免被其他類引用，有以下這些方法，
  但實際上有其他方法，EX：用Void來取得數據

- 而且封裝在物件導向有時不是指數據封裝，是指類別封裝，將類別關起來

> public：所有對象都可以訪問；
> private：對象本身在對象內部可以訪問；
> protected：只有該類對象及其子類對象可以訪問
> internal：同一個程式集的對象可以訪問；
> protected internal：訪問限於當前程式集或派生自包含類的類型。

> get {return _firstName;}set {_firstName = value;} <=利用函式取得封裝數據



## 3.繼承
- 指的是子類繼承父類，而子類有父類所有非私有的數據，就是把父類的程式碼塞到子類裡
- C＃ 只能單一繼承

```csharp
public class A //父類
{
Protected int value = 10;
}

public class B : A//子類
{
public int GetValue(){return this.value;}
}

ClassB繼承後實際上程式碼變成這樣
public class B //子類
{
protected int value = 10;//這是父類的
public int GetValue(){return this.value;}//這是子類的
}
```

## 4.多態
- 就是一個類可以有很多種型態
EX:當子類繼承父類，宣告父類陣列時，子類也能放進去，因為子類有父類的型態
EX2:當類繼承介面Interface 宣告Interface 陣列時該類也能放進去，因為該類有Interface 型態

- 還有就是Void（函示）多態，只要後面接的變數不一樣，函示名字可以一樣
```
EX: 
Test()
Test(int a)
Test(int a,string b)
```


----------


# 設計模式7大原則

## 1.開閉原則

> 詳見 [程序员必备的七大面向对象设计原则（一）](https://blog.csdn.net/qiulongtianshi/article/details/7570021)

### **定義 : 對擴展開放，對修改關閉** 

#### 原則:
1. 開閉原則由Bertrand Meyer於1988年提出，它是面向對象設計中最重要的原則之一。
2. 在開閉原則的定義中，軟體實體可以指一個軟體模組、一個由多個類組成的局部結構或一個獨立的類。
3. 抽象化是開閉原則的關鍵。
4. 開閉原則還可以通過一個更加具體的“對可變性封裝原則”來描述，對可變性封裝原則(Principle of Encapsulation of Variation,EVP)要求找到系統的可變因素並將其封裝起來。


#### 案例:

![](https://github.com/PeterLukGit/My_Unity_Exercise/blob/master/%E7%AD%86%E8%A8%98/%E7%AD%86%E8%A8%98%E5%9C%96%E7%89%87/%E9%96%8B%E9%96%89%E5%8E%9F%E5%89%87/00.PNG)


對比分析
圖（1）：客戶端的一個方法直接調用加法類，但是我想添加一個減法類，你就會發現添加減法類就得改變加法類中代碼（用switch語句實現），這就違背了“開閉原則”，於是我們就應該重新重構。
如圖（2）在這個圖中我們添加了一個運算類的父類，這樣我們再添加減法類的時候就不用修改客戶端類。

開閉原則總結：面對需求，對程式的改動是通過增加新代碼進行的，而不是改變原來的代碼。

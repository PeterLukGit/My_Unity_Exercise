<!DOCTYPE html>
<!-- saved from url=(0038)http://acegikmo.com/shaderforge/nodes/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<script async="" src="./Shader Forge_files/analytics.js.下載"></script><script>

			// JQuery
		    document.write("\<script src='//ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js' type='text/javascript'>\<\/script>");
	


			// Google analytics
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-40853469-2', 'acegikmo.com');
			ga('send', 'pageview');

			var nodeList = new Array();nodeList[0] = "main";
nodeList[1] = "add";
nodeList[2] = "subtract";
nodeList[3] = "multiply";
nodeList[4] = "divide";
nodeList[5] = "reciprocal";
nodeList[6] = "power";
nodeList[7] = "sqrt";
nodeList[8] = "log";
nodeList[9] = "min";
nodeList[10] = "max";
nodeList[11] = "abs";
nodeList[12] = "sign";
nodeList[13] = "ceil";
nodeList[14] = "round";
nodeList[15] = "floor";
nodeList[16] = "trunc";
nodeList[17] = "stepaltb";
nodeList[18] = "smoothstep";
nodeList[19] = "if";
nodeList[20] = "frac";
nodeList[21] = "fmod";
nodeList[22] = "clamp";
nodeList[23] = "clampsimple";
nodeList[24] = "clamp0-1";
nodeList[25] = "lerp";
nodeList[26] = "lerpsimple";
nodeList[27] = "inverselerp";
nodeList[28] = "posterize";
nodeList[29] = "blend";
nodeList[30] = "remap";
nodeList[31] = "remapsimple";
nodeList[32] = "noise";
nodeList[33] = "oneminus";
nodeList[34] = "negate";
nodeList[35] = "exp";
nodeList[36] = "hue";
nodeList[37] = "hsvtorgb";
nodeList[38] = "rgbtohsv";
nodeList[39] = "value";
nodeList[40] = "vector2";
nodeList[41] = "vector3";
nodeList[42] = "vector4";
nodeList[43] = "texture2d";
nodeList[44] = "textureasset";
nodeList[45] = "valueproperty";
nodeList[46] = "vector4property";
nodeList[47] = "color";
nodeList[48] = "cubemap";
nodeList[49] = "slider";
nodeList[50] = "switch";
nodeList[51] = "toggle";
nodeList[52] = "dotproduct";
nodeList[53] = "crossproduct";
nodeList[54] = "reflect";
nodeList[55] = "normalize";
nodeList[56] = "append";
nodeList[57] = "componentmask";
nodeList[58] = "desaturate";
nodeList[59] = "channelblend";
nodeList[60] = "normalblend";
nodeList[61] = "distance";
nodeList[62] = "length";
nodeList[63] = "transform";
nodeList[64] = "vectorprojection";
nodeList[65] = "vectorrejection";
nodeList[66] = "ddx";
nodeList[67] = "ddy";
nodeList[68] = "ddxy";
nodeList[69] = "panner";
nodeList[70] = "rotator";
nodeList[71] = "parallax";
nodeList[72] = "uvtile";
nodeList[73] = "uvcoordinates";
nodeList[74] = "objectposition";
nodeList[75] = "objectscale";
nodeList[76] = "screenposition";
nodeList[77] = "worldposition";
nodeList[78] = "vertexcolor";
nodeList[79] = "fresnel";
nodeList[80] = "normaldirection";
nodeList[81] = "bitangentdirection";
nodeList[82] = "tangentdirection";
nodeList[83] = "viewdirection";
nodeList[84] = "viewreflection";
nodeList[85] = "facesign";
nodeList[86] = "lightcolor";
nodeList[87] = "lightattenuation";
nodeList[88] = "ambientlight";
nodeList[89] = "lightdirection";
nodeList[90] = "halfdirection";
nodeList[91] = "lightposition";
nodeList[92] = "time";
nodeList[93] = "viewposition";
nodeList[94] = "projectionparameters";
nodeList[95] = "screenparameters";
nodeList[96] = "pixelsize";
nodeList[97] = "fogcolor";
nodeList[98] = "scenecolor";
nodeList[99] = "scenedepth";
nodeList[100] = "depthblend";
nodeList[101] = "depth";
nodeList[102] = "pi";
nodeList[103] = "tau";
nodeList[104] = "phigoldenratio";
nodeList[105] = "root2";
nodeList[106] = "eeulersconstant";
nodeList[107] = "sin";
nodeList[108] = "cos";
nodeList[109] = "tan";
nodeList[110] = "arcsin";
nodeList[111] = "arccos";
nodeList[112] = "arctan";
nodeList[113] = "arctan2";
nodeList[114] = "matrix4x4";
nodeList[115] = "matrix4x4property";
nodeList[116] = "multiplymatrix";
nodeList[117] = "transpose";
nodeList[118] = "code";
nodeList[119] = "relay";
nodeList[120] = "set";
nodeList[121] = "get";

			function scrollTo(hash) {
			    location.hash = "#" + hash;
			}


			function OnUpdateSearchField(){
				var searchString = document.getElementsByName("searchfield")[0].value.toLowerCase().trim();
				searchString = searchString.replace(/\s+/g, '');

				var alwaysShow = true;
				if(searchString.length > 0)
					alwaysShow = false;

				var matchedAny = false;
				for(var i=0;i<nodeList.length;i++){
					if((nodeList[i].indexOf(searchString) != -1) || alwaysShow){
						ShowDiv(nodeList[i]);
						matchedAny = true;
					} else {
						HideDiv(nodeList[i]);
					}
				}

				if(matchedAny){
					HideDiv("search_not_found");
				} else {
					ShowDiv("search_not_found");
				}

			}

			function ShowDiv(id){
				document.getElementById(id).style.display="";
			}

			function HideDiv(id){
				document.getElementById(id).style.display="none";
			}

		</script><script src="./Shader Forge_files/jquery.min.js.下載" type="text/javascript"></script>
		
		

		<!-- Header -->
		<link rel="shortcut icon" type="image/png" href="http://www.acegikmo.com/shaderforge/images/web/favicon_32x32.png">
		<title>Shader Forge</title>
		<!-- CSS -->
		<link rel="stylesheet" type="text/css" href="./Shader Forge_files/styles.css">



	</head>

	<body onload="OnUpdateSearchField()">






		<div class="page_wrapper">

			<div class="main_header">
				<a href="http://acegikmo.com/shaderforge/"><img src="./Shader Forge_files/sf_logo.png"></a>
			</div>

			<div style="display:inline-block;">
				<div class="header_quote">
					<div class="mainpage_quote_body">“It turns the dark and strange arts of shader programming into something understandable and non-evil”</div><div class="mainpage_quote_author"><a href="http://nifflas.ni2.se/">Nicklas 'Nifflas' Nygren</a>, developer of the Knytt series</div>				</div>

				<br>
				<div class="navbar">
					<a class="button" href="http://neatcorporation.com/forums/viewforum.php?f=1">Forums</a>
					<a class="button" href="http://acegikmo.com/shaderforge/tutorials/">Tutorials</a>
					<a class="button" href="http://acegikmo.com/shaderforge/nodes/">Nodes</a>
					<a class="button" href="http://acegikmo.com/shaderforge/wiki/">Wiki</a>
					<a class="button" href="http://acegikmo.com/shaderforge/faq/">FAQ</a>
					<a class="button" href="http://acegikmo.com/shaderforge/changelog/">Changelog</a>
					<a class="button" href="http://shaderforge.userecho.com/" target="_blank">Feedback</a>

				</div>
			</div>
			<div class="header_separator"></div>

			<!-- <div class="notification_bg"><a href="https://bitly.com/sf_form" class="notification_text">Take a survey - help shape Shader Forge 2!</a></div> -->






<div class="node_desc_header"><div class="search_label">Search Box</div><input type="text" name="searchfield" value="" onchange="OnUpdateSearchField()" onkeyup="OnUpdateSearchField()" onload="OnUpdateSearchField()" onkeydown="OnUpdateSearchField()"><br><div class="node_upper_separator"></div><div class="search_not_found" id="search_not_found" style="display:none;">None of the nodes matched your search :(</div><br><a href="http://acegikmo.com/shaderforge/nodes/">Eng</a> - <a href="http://acegikmo.com/shaderforge/nodes/?lang=zh_cn">简体字</a> - <a href="http://acegikmo.com/shaderforge/nodes/?lang=zh_tw">正體字</a><br><a href="http://www.neatcorporation.com/Projects/ShaderForge/Media/ShaderForge_QuickStart-en.pdf">Beginner's tutorial</a><br></div><div class="node_list"><div class="node_desc_wrapper" id="main"><div class="node_desc_title">Main</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">This is the node in which all your other nodes in the end link to. It has several inputs that all serve different purposes.<br>
		The animated images below show all of the inputs and how they behave when changed over time. Most of them animate back and forth between 0 and 1 (Black and White)<br><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffuse.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse</div><div class="node_desc_main_input_desc">This is the main color of your shaders. The diffuse color will receive light, have light falloff depending on the light-normal angle, and be shaded by shadows.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffusepower.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse Power</div><div class="node_desc_main_input_desc">This is the exponent of the falloff of the light-normal angle. Can be used to get an extra metallic look when using values above 1. Note that this does not currently conserve energy, whenever that is enabled.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_specular.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Specular</div><div class="node_desc_main_input_desc">This is the color of the specular highlights of your shader. Higher values are brighter, black will not affect the shader at all.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_gloss.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Gloss</div><div class="node_desc_main_input_desc">This is the exponent of the specular highlights. Higher values will make it look shiny, values approaching 0 will make it look matte. Note that if you have unchecked gloss remapping, you should avoid using gloss values below 1.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_normal.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Normal</div><div class="node_desc_main_input_desc">This is the tangent-space normal direction, where you can connect normal maps or custom normal vectors.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_emission.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Emission</div><div class="node_desc_main_input_desc">This is simply light that is always added to your shader, regardless of the lighting conditions. </div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_transmission.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Transmission</div><div class="node_desc_main_input_desc">This controls how much light is passed through when the light source is behind the surface currently being rendered. This can be useful for thin materials such as cloth or vegetation.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_lightwrapping.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Light Wrapping</div><div class="node_desc_main_input_desc">This is a way of controlling the light-normal angle falloff offset, which can be used to get an effect similar to subsurface scattering. Works best for smooth objects. Inputting a red-ish value will make the red channel "wrap around" the object more than the others, making it look as if light passed into the mesh, and came out with a red wavelength, similar to how skin is shaded.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffuseambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse Ambient Light</div><div class="node_desc_main_input_desc">This adds light to your shader, affected by your diffuse. Can be used with, for example, cubemap using the normal direction for image-based lighting (IBL), or ambient light</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_specularambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Specular Ambient Light</div><div class="node_desc_main_input_desc">This adds light to your shader, affected by your specular. Can be used with, for example, a cubemap using the view reflection direction for image-based lighting (IBL)</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffuseambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse Ambient Occlusion</div><div class="node_desc_main_input_desc">This dampens indirect diffuse light, such as light probes, indirect light, and diffuse ambient light</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_specularambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Specular Ambient Occlusion</div><div class="node_desc_main_input_desc">This dampens indirect specular light, such as reflection probes, and specular ambient light</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_customlighting.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Custom Lighting</div><div class="node_desc_main_input_desc">This input is active when your shader is set to unlit, allowing you to define custom lighting behaviour. The nodes you put here are per-light.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_alpha.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Opacity</div><div class="node_desc_main_input_desc">Opacity controls the transparency of the final pixel. Note that partial transparency is generally finicky to get right, especially when using deferred rendering.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_alphaclip.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Opacity Clip</div><div class="node_desc_main_input_desc">Opacity Clip is a way of controlling if the current pixel/fragment should draw or not. Always use Opacity Clip for objects that need transparency, but not partial transparency, as Opacity Clip is easily sorted, which Opacity is not.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_refraction.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Refraction</div><div class="node_desc_main_input_desc">Refraction is a screen-space UV offset for refracting the background pixels. Make sure you set the alpha to something below 1 before using, so that the refraction effect is visible. </div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_outlinewidth.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Outline Width</div><div class="node_desc_main_input_desc">This will add an outline to your shader, rendered as an offset mesh with reversed face normals. Note that hard edges will break the outline.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_outlinecolor.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Outline Color</div><div class="node_desc_main_input_desc">This controls the color of the outline.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_vertexoffset.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Vertex Offset</div><div class="node_desc_main_input_desc">This can be used to animate shaders over time, or change the shape of the object in various conditions. You simply insert a XYZ coordinate for how much each vertex should be offset.</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_displacement.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">DX11 Displacement</div><div class="node_desc_main_input_desc">This works very much in the same way as Vertex Offset, but is used in conjunction with DX11 tessellation. (Note that DirectX is Windows only, requires a DX11 GPU and has to be enabled in Unity)</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_tessellation.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">DX11 Tessellation</div><div class="node_desc_main_input_desc">This controls how many subdivisions you want to split your triangles into. (Note that DirectX is Windows only, requires a DX11 GPU and has to be enabled in Unity)</div></div></div><br>
		</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="add"><div class="node_desc_title">Add<div class="node_desc_title_hotkey"> A + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_add.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the sum [A] + [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="subtract"><div class="node_desc_title">Subtract<div class="node_desc_title_hotkey"> S + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_subtract.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the difference [A] - [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="multiply"><div class="node_desc_title">Multiply<div class="node_desc_title_hotkey"> M + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_multiply.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the product [A] * [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="divide"><div class="node_desc_title">Divide<div class="node_desc_title_hotkey"> D + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_divide.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the quotient [A] / [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="reciprocal"><div class="node_desc_title">Reciprocal</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the quotient 1 / input</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="power"><div class="node_desc_title">Power<div class="node_desc_title_hotkey"> E + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_power.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the power [Val] ^ [Exp]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="sqrt"><div class="node_desc_title">Sqrt</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the square root of its input</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="log"><div class="node_desc_title">Log</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the logarithm of its input. You can switch log base in the dropdown menu</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="min"><div class="node_desc_title">Min</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_min.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the minimum of [A] and [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="max"><div class="node_desc_title">Max</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_max.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the maximum of [A] and [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="abs"><div class="node_desc_title">Abs</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_abs.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the absolute value of its input. Essentially; it makes negative values positive</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="sign"><div class="node_desc_title">Sign</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_sign.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the sign of its input.<br>
		Values greater than 0 outputs 1<br>
		Values equal to 0 outputs 0<br>
		Values less than 0 outputs -1</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ceil"><div class="node_desc_title">Ceil</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_ceil.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its input rounded up to the nearest integer</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="round"><div class="node_desc_title">Round</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_round.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its input rounded to the nearest integer</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="floor"><div class="node_desc_title">Floor</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_floor.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its input rounded down to the nearest integer</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="trunc"><div class="node_desc_title">Trunc</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_trunc.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its input rounded to the nearest integer towards zero. Essentially; it removes the decimals, leaving an integer</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="stepaltb"><div class="node_desc_title">Step (A &lt;= B)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_step.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs 1 if [A] is less than or equal to [B], otherwise outputs 0</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="smoothstep"><div class="node_desc_title">Smoothstep</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Blends smoothly between two values, based on where a third value is in that range, outputting values between 0 and 1. Think of it as a clamped inverse lerp with a smoothed output value.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="if"><div class="node_desc_title">If<div class="node_desc_title_hotkey"> I + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the [A&gt;B] input when [A] is greater than [B]<br>
		Outputs the [A=B] input when [A] is equal to [B]<br>
		Outputs the [A&lt;B] input when [A] is less than [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="frac"><div class="node_desc_title">Frac</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_frac.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the fractional part of its input. Essentially; it removes the integer part and keeps only the decimal part. An input of 4.32 would output 0.32. This node is particularly useful in conjunction with the Time node, which gives you a sawtooth wave over time</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="fmod"><div class="node_desc_title">Fmod</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the remainder of [A] divided by [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="clamp"><div class="node_desc_title">Clamp</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its main input value, no less than [Min] and no more than [Max]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="clampsimple"><div class="node_desc_title">Clamp (Simple)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">The same as Clamp, but with two numerical inputs for Min and Max instead of node connectors</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="clamp0-1"><div class="node_desc_title">Clamp 0-1</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_clamp01.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its input value, no less than 0 and no more than 1</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lerp"><div class="node_desc_title">Lerp<div class="node_desc_title_hotkey"> L + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lerp.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Lerp is used to blend between two values or colors.<br>
		If [T] is 0, it will output [A]<br>
		If [T] is 0.5, it will output a halfway blend between [A] and [B]<br>
		If [T] is 1, it will output [B]<br>
		If [T] is any other value, it will output a linear blend of the two.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lerpsimple"><div class="node_desc_title">Lerp (Simple)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">The same as Lerp, but with two numerical inputs for [A] and [B] instead of node connectors</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="inverselerp"><div class="node_desc_title">InverseLerp</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_inverselerp.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">InverseLerp is usually used to remap ranges.<br>
		If [T] is equal to [A], it will output 0<br>
		If [T] is halfway between [A] and [B], it will output 0.5<br>
		If [T] is equal to [B], it will output 1<br>
		If [T] is any other value, it will output a linear blend of the two.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="posterize"><div class="node_desc_title">Posterize</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_posterize.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Rounds values based on the value coming through [Steps]. A [Steps] value of 5 will create 5 bands in the 0 to 1 range</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="blend"><div class="node_desc_title">Blend<div class="node_desc_title_hotkey"> B + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_blend.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Blends A over B using the specified method</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="remap"><div class="node_desc_title">Remap</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_remaprangeadvanced.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Remaps a value from one range to another. Same as Remap (Simple), but with inputs instead of numerical constants</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="remapsimple"><div class="node_desc_title">Remap (Simple)<div class="node_desc_title_hotkey"> R + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_remaprange.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Remaps a value from one range to another. For instance, if the node expects values from -1 to 1, but you want it to output a value from 2 to 5, you can type -1 and 1 on the first line, 2 and 5 on the second line</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="noise"><div class="node_desc_title">Noise</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_noise.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Generates pseudorandom numbers based on a two-component input (Such as UV coordinates)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="oneminus"><div class="node_desc_title">One Minus<div class="node_desc_title_hotkey"> O + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_oneminus.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs 1 minus its input. When used with color inputs, it will invert the color</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="negate"><div class="node_desc_title">Negate</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_negate.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the main input multiplied by -1. Essentially makes positive values negative, and negative values positive</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="exp"><div class="node_desc_title">Exp</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">When Exp is selected: Outputs e to the power of its input<br>
		When Exp 2 is selected: Outputs 2 to the power of its input</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="hue"><div class="node_desc_title">Hue</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_hue.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs an RGB color given a Hue</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="hsvtorgb"><div class="node_desc_title">HSV to RGB</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_hsvtorgb.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs an RGB color given a HSV (Hue, Saturation and Value) input. Hue and Saturation are between 0 and 1. Value is too, but can go beyond 1 to overexpose colors</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="rgbtohsv"><div class="node_desc_title">RGB to HSV</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_rgbtohsv.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs HSV (Hue, Saturation and Value) components given a color input. Hue and Saturation are between 0 and 1. Value can go beyond 1 for overexposed colors</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="value"><div class="node_desc_title">Value<div class="node_desc_title_hotkey"> 1 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A numerical value, can also be called a "Vector 1". A property version is also available. Values can be used with the Append node to create Vectors with more components. Values can also be multiplied with vectors/colors. For example, a vector (3,1,0) multiplied by a value of 0.5, outputs the vector (1.5,0.5,0)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector2"><div class="node_desc_title">Vector 2<div class="node_desc_title_hotkey"> 2 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A vector with two components/values. Usually used with UV coordinates. Adding a Vector 2 to UV coordinates, will translate the UVs. Multiplying UV coordinates with a Vector 2 will scale the UVs</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector3"><div class="node_desc_title">Vector 3<div class="node_desc_title_hotkey"> 3 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A vector with three components/values. Usually used as a color, position or direction</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector4"><div class="node_desc_title">Vector 4<div class="node_desc_title_hotkey"> 4 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A vector with four components/values. Usually used as a color with an alpha channel, or as a position with some extra data in the fourth channel. There are two parameters to expose in the inspector available. Color and Vector 4 parameter</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="texture2d"><div class="node_desc_title" style="color:#53b19c;">Texture 2D<div class="node_desc_title_hotkey"> T + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tex2d.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Contains a reference to a texture and will sample a texture at a specific UV coordinate with a specific MIP level (if connected). If the [Tex] input is connected by a Texture Asset node, this will no longer be a parameter in the inspector. Outputs [RGB] as well as separate channels</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="textureasset"><div class="node_desc_title" style="color:#53b19c;">Texture Asset</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tex2dasset.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Contains a reference to a texture. This is used to sample a single texture multiple times - Can only be connected to the [Tex] input of Texture 2D nodes. This will also be reflected in the inspector of the material, so the user only need to assign one texture</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="valueproperty"><div class="node_desc_title" style="color:#53b19c;">Value (Property)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A numerical value; same as Value, but exposed in the material inspector</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector4property"><div class="node_desc_title" style="color:#53b19c;">Vector 4 (Property)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A vector with four components/values, same as Vector 4, but exposed in the material inspector as 4 separate X, Y, Z and W values</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="color"><div class="node_desc_title" style="color:#53b19c;">Color</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A vector with four components/values, same as Vector 4, but exposed in the material inspector with a color picker</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="cubemap"><div class="node_desc_title" style="color:#53b19c;">Cubemap</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Contains a reference to a cubemap and will sample a it in a specific direction with a specific MIP level (If connected). Outputs [RGB] as well as separate channels</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="slider"><div class="node_desc_title" style="color:#53b19c;">Slider</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Allows you to easily tweak a value between a min and a max value. Is also exposed to the inspector</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="switch"><div class="node_desc_title" style="color:#53b19c;">Switch</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_switchproperty.gif"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Switches between two inputs based on a checkbox. Note that this cannot be used to optimize a shader, it will process both branches, but only show one</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="toggle"><div class="node_desc_title" style="color:#53b19c;">Toggle</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A value that is either 0 or 1 based on a checkbox</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="dotproduct"><div class="node_desc_title">Dot Product</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the Dot product between [A] and [B]. Essentially; for two normalized vectors, it outputs how far they point away from each other. If they point in the same direction, it outputs 1, if they are perpendicular to each other, it outputs 0, if they point in opposite directions, it outputs -1.<br>
		Dropdown selections:<br>
		Standard - Regular Dot Product<br>
		Positive - Makes all negative values 0<br>
		Negative - Makes all positive values 0<br>
		Abs - Makes all negative values positive<br>
		Normalized - Outputs in the range 0 to 1 instead of -1 to 1<br>
		<br>
		The graph below show how the different modes behave when using two normalized vectors.<br>
		On the X axis you have the angle between them, on the Y axis you have the output value:<br>
		<img src="./Shader Forge_files/sfn_dot.jpg"></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="crossproduct"><div class="node_desc_title">Cross Product</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the Cross product of [A] and [B]. Essentially; it outputs a vector perpendicular to both input vectors</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="reflect"><div class="node_desc_title">Reflect</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the reflection vector of an incoming vector [I] as if reflected/bounced on a surface with the normal [N]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="normalize"><div class="node_desc_title">Normalize<div class="node_desc_title_hotkey"> N + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the normalized version of the input vector. Essentially; sets the length of the vector to 1, while keeping the same direction</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="append"><div class="node_desc_title">Append<div class="node_desc_title_hotkey"> Q + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_append.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs a single vector from multiple input values/vectors. For example, if [A] is a Vector 2, and [B] is a Value (Vector 1), the node will output a Vector 3, where [A] is in the red and green channel, while [B] is in the blue channel</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="componentmask"><div class="node_desc_title">Component Mask<div class="node_desc_title_hotkey"> C + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_componentmask.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">The component mask can be used to reorder or extract channels of a vector</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="desaturate"><div class="node_desc_title">Desaturate</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_desaturate.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs a desaturated version of the input [Col]. [Des] Determines how desaturated it is. A value of 1 means fully desaturated, 0.5 means half-desaturated, 0 means no desaturation</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="channelblend"><div class="node_desc_title">Channel Blend</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_channelblend.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the sum of each component of the mask multiplied by the corresponding color input. Useful for triplanar blending</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="normalblend"><div class="node_desc_title">Normal Blend</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Combines two tangent-space normal directions, where the base normal is perturbed by the detail normal</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="distance"><div class="node_desc_title">Distance</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_distance.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the distance between the two input points [A] and [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="length"><div class="node_desc_title">Length</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_length.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the length/magnitude of its input vector</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="transform"><div class="node_desc_title">Transform</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Transforms a vector from one space to another. You can switch between world/local/tangent/view. The built-in vectors are in world space. Directions into the normal input is in tangent space.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vectorprojection"><div class="node_desc_title">Vector Projection</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs vector [A] projected onto vector [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vectorrejection"><div class="node_desc_title">Vector Rejection</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs vector [A] rejected from vector [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ddx"><div class="node_desc_title">DDX</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the partial derivative (rate of change) of the input vector in screen space along the X-axis</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ddy"><div class="node_desc_title">DDY</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the partial derivative (rate of change) of the input vector in screen space along the Y-axis</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ddxy"><div class="node_desc_title">DDXY</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the absolute sum of the two partial derivatives (rate of change) of the input vector in screen space along the X and Y-axis. Known as fwidth() in code.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="panner"><div class="node_desc_title">Panner<div class="node_desc_title_hotkey"> P + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the input [UV] coordinates, panned/offset by [Dist] distance, in the direction/speed specified by the U and V parameters</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="rotator"><div class="node_desc_title">Rotator</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_rotator.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the input [UV] coordinates rotated by [Ang] radians around the pivot point [Piv]. If [Ang] is not connected, or connected to a time node, [Spd] will control the rotation speed</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="parallax"><div class="node_desc_title">Parallax</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the input [UV] coordinates with a parallax offset derived from the [Hei] input, with a depth of [Dep] and a reference height [Ref].<br>
		A [Ref] height of 0 means it will parallax as if the heightmap sticks out from the mesh<br>
		A [Ref] height of 1 means it will parallax as if the heightmap goes down into the mesh<br></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="uvtile"><div class="node_desc_title">UV Tile</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_uvtile.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">UV Tile can be used to get a tile within a tilemap, in the form of UV coordinates.<br>
		[UV] is the base UVs to get a tile inside<br>
		[Wid] is the amount of tiles along the tilemap's width<br>
		[Hei] is the amount of tiles along the tilemap's height<br>
		[Tile] is the index of the tile in the tilemap you want to extract. Specify this as an integer, where 0 is the first tile, starting from the bottom left.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="uvcoordinates"><div class="node_desc_title">UV Coordinates<div class="node_desc_title_hotkey"> U + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the specified UV coordinate for this part of the geometry. The dropdown allows you to select either UV channel 0 or UV channel 1. Note that lightmapped meshes use UV1 for their lightmap UVs</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="objectposition"><div class="node_desc_title">Object Position</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_objectposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the world position of the object's pivot point</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="objectscale"><div class="node_desc_title">Object Scale</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_objectscale.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the scale of the object. Checking reciprocal is computationally cheaper, but gives you the inverse scale (1 / scale). Note that this will not work if the mesh is batched.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="screenposition"><div class="node_desc_title">Screen Position</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_screenpos.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the screen position of the current part of the mesh, can be used as UV coordinates for screen-space mapping. In the dropdown box, "Normalized" will put {0,0} in the center of the screen, and {1,1} in the top right. "Tiled" will keep {0,0} in the center, but will scale on the X axis based on your aspect ratio</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="worldposition"><div class="node_desc_title">World Position</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_fragmentposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the position of the current part of the mesh in world space</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vertexcolor"><div class="node_desc_title">Vertex Color<div class="node_desc_title_hotkey"> V + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_vertexcolor.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the vertex color. If you've baked ambient occlusion in the vertex colors, or want to tint the mesh with painted colors, or use vertex colors for anything else, this is the node you want</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="fresnel"><div class="node_desc_title">Fresnel</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_fresnel.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the dot product between the surface normal and the view direction. [Nrm] is used if you want to use a custom normal. By default, the perturbed normal is used. [Exp] changes the exponent of the output. Higher values will make the fresnel thinner</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="normaldirection"><div class="node_desc_title">Normal Direction</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_normalvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the direction of the mesh normal, in world space. The Perturbed checkbox makes it use the normals after having applied the "Normal" input of the main node, such as a normal map.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="bitangentdirection"><div class="node_desc_title">Bitangent Direction</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_binormal.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the direction of the mesh bitangent, in world space</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="tangentdirection"><div class="node_desc_title">Tangent Direction</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tangent.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the direction of the mesh tangent, in world space</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="viewdirection"><div class="node_desc_title">View Direction</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_viewvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the direction from the current part of the geometry to the camera, in world space</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="viewreflection"><div class="node_desc_title">View Reflection</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_viewreflectionvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the direction of the view as if bounced according to the surface normal. This can be used as input for cubemaps for perfect reflections</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="facesign"><div class="node_desc_title">Face Sign</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_facesign.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">This is used to detect if the current face is a frontface or a backface. Outputs 1 on frontfaces, and either -1 or 0 for backfaces, depending on what you specify in the dropdown box.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightcolor"><div class="node_desc_title">Light Color</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightcolor.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the color of the current light being rendered</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightattenuation"><div class="node_desc_title">Light Attenuation</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightattenuation.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the light attenuation. This node contains both the light falloff and shadows in one</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ambientlight"><div class="node_desc_title">Ambient Light</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_ambientlight.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the ambient light of the scene the shader is being rendered in</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightdirection"><div class="node_desc_title">Light Direction</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the direction to the current light being rendered</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="halfdirection"><div class="node_desc_title">Half Direction</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_halfvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the half-direction. This is the direction that points halfway between the view and the light vector, which is commonly used in the blinn-phong specular model</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightposition"><div class="node_desc_title">Light Position</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the position of the current light being rendered. <br>[Pnt] Outputs 1 if the current light being rendered is a point light, otherwise it outputs 0</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="time"><div class="node_desc_title">Time</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_time.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs time at different rates.<br>
		[t/20] outputs the time running 20 times slower<br>
		[t] outputs the current time<br>
		[t*2] outputs the time running twice as fast<br>
		[t*3] outputs the time running thrice as fast</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="viewposition"><div class="node_desc_title">View Position</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_viewposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the current location of the view/camera (Note that when using perspective cameras, the view position is "behind" the screen)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="projectionparameters"><div class="node_desc_title">Projection Parameters</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_projectionparameters.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs four projection parameters.<br>
		[Sign] is -1 if currently rendering with a flipped projection matrix, otherwise it's 1<br>
		[Near] is the near plane distance of the current camera<br>
		[Far] is the far plane distance of the current camera<br>
		[1/Far] is the reciprocal distance of the far plane</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="screenparameters"><div class="node_desc_title">Screen Parameters</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_screenparameters.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs four screen parameters.<br>
		[pxW] is the width of the screen in pixels<br>
		[pxH] is the height of the screen in pixels<br>
		[1+1/W] is 1 plus the reciprocal of the screen pixel width<br>
		[1+1/H] is 1 plus the reciprocal of the screen pixel height</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="pixelsize"><div class="node_desc_title">Pixel Size</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the size of each pixel as a percentage of the screen width and height.<br>
		For example, with a resolution of 8x4, this would output a vector with values (0.125, 0.25)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="fogcolor"><div class="node_desc_title">Fog Color</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_fogcolor.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the color of the fog in the current scene</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="scenecolor"><div class="node_desc_title">Scene Color</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A texture containing a render of the scene before this object was rendered. By default, its UVs are in screen space, making each pixel represent the color behind the object. This can be used for more advanced blending/transparency effects, or a manual way of making refraction if the UVs are altered, among other things </div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="scenedepth"><div class="node_desc_title">Scene Depth</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">The depth from the camera to the scene behind the current pixel. Note: You have to turn off depth buffer writing in the blend settings, and you need to use a <a href="http://docs.unity3d.com/Documentation/Components/SL-CameraDepthTexture.html">camera that renders a depth texture</a></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="depthblend"><div class="node_desc_title">Depth Blend</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">This outputs a value between 0 and 1, depending on how close this pixel is to the background geometry, based on the distance input. Useful for fading out edges of water, or softening up lightshafts intersecting geometry. Note: You have to turn off depth buffer writing in the blend settings, and you need to use a <a href="http://docs.unity3d.com/Documentation/Components/SL-CameraDepthTexture.html">camera that renders a depth texture</a></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="depth"><div class="node_desc_title">Depth</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">This is the distance from the camera's near plane to the object itself</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="pi"><div class="node_desc_title">Pi</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_pi.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the value of Pi, the ratio of a circle's circumference to its diameter (Approximately 3.141593)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="tau"><div class="node_desc_title">Tau</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tau.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the value of Tau, the ratio of a circle's circumference to its radius (Approximately 6.283185)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="phigoldenratio"><div class="node_desc_title">Phi (Golden ratio)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_phi.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the value of Phi, the golden ratio (Approximately 1.618034)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="root2"><div class="node_desc_title">Root 2</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_root2.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the square root of two (Approximately 1.414214)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="eeulersconstant"><div class="node_desc_title">e (Euler's Constant)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_e.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs Euler's constant e (Approximately 2.718282)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="sin"><div class="node_desc_title">Sin</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the sine of its input</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="cos"><div class="node_desc_title">Cos</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the cosine of its input</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="tan"><div class="node_desc_title">Tan</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the tangent of its input</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arcsin"><div class="node_desc_title">ArcSin</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the arcsine of its input, in radians</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arccos"><div class="node_desc_title">ArcCos</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the arccosine of its input, in radians</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arctan"><div class="node_desc_title">ArcTan</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the arctangent of its input, in radians</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arctan2"><div class="node_desc_title">ArcTan2</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_arctan2.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the arctangent of its two inputs coordinates. The range and unit depends on the dropdown box. By default it's in radians, from -pi to pi.</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="matrix4x4"><div class="node_desc_title">Matrix 4x4</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_matrix4x4.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A constant matrix. The initial values are that of an identity matrix</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="matrix4x4property"><div class="node_desc_title">Matrix 4x4 Property</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_matrix4x4property.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A matrix property. You can assign to it on the C# end using myMaterial.SetMatrix</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="multiplymatrix"><div class="node_desc_title">Multiply Matrix</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_multiplymatrix.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A matrix multiply node. Can be used to transform vectors, spaces, or other matrices. You can assign to it on the C# end using myMaterial.SetMatrix(). Note that matrix multiplication is not commutative. That is to say, A * B is not the same thing as B * A</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="transpose"><div class="node_desc_title">Transpose</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs the transpose of a matrix</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="code"><div class="node_desc_title">Code</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_code.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">A node for doing custom code inside a shader. In the example to the left, the node will work similar to a lerp, that curves towards [mid] before reaching [end]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="relay"><div class="node_desc_title">Relay</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_relay.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Outputs its input, useful for organizing node connections</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="set"><div class="node_desc_title">Set</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_set.gif"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Saves a variable to be reused later. Useful for cleaning up large node trees</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="get"><div class="node_desc_title">Get</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_get.gif"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Gets one of the previously defined variables using the Set node. Useful for cleaning up large node trees</div></td></tr></tbody></table></div></div></div></div>		



		<div class="footer">
			Shader Forge © Freya 'Acegikmo' Holmér<br>
			webmaster@acegikmo.com
		</div>



		</div>
	
</body></html>